---
layout: post
date: "2008-12-06 12:54:55"
disquss_thread_id: 41421357
title: "Programming by Intention"
category: archive
---
In an area dominated by acronyms like [DRY](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself), [YAGNI](http://c2.com/xp/YouArentGonnaNeedIt.html), [FIRST](http://blog.objectmentor.com/articles/2008/03/06/tdd-on-three-index-cards), [SMART](http://xp123.com/xplor/xp0308/index.shtml), [KISS](http://en.wikipedia.org/wiki/KISS_principle) or catchy expressions such as [Fake It Till You Make It](http://en.wikipedia.org/wiki/Fake_it_till_you_make_it) and [Baby Steps](http://agilesoftwaredevelopment.com/baby-steps), a very important practice which is becoming forgotten is [Programming By Intention](http://www.ehow.com/how_2001455_write-effective-object-oriented-code.html):

> This is the practice of pretending that classes, functions, procedures etc. exist (even though they do not) as you structure and write your code. This helps a developer think about the overall process and larger steps of software rather than the small details.

Although it may sound a little weird, the definition above really points to essence of this practice: pretending a piece of code is there to help you focus on the bigger picture. It forces us to think about what we're trying to achieve instead of going into all the details first. And this small change in priorities makes a huge difference.

As [critical thinkers](http://en.wikipedia.org/wiki/Critical_thinking) we are always breaking the problem into smaller pieces and trying to put them together like a puzzle. And sometimes we decide to build these pieces one by one in sequence, and not by importance. By adopting this approach we lose great opportunities to learn early about the solution we're building. We also lose time refactoring and  throwing out code when we realise the pieces could be arranged in a simpler or more understandable way.

And that's where the beauty of [Programming By Intention](http://www.xprogramming.com/xpmag/acsIntention.htm) lies: it effectively helps us to make sure we're solving the problem first, and writing all the support for the solution later.

And that's why I wish there was a buzzword for it too.
